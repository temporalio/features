package validation_replay

import (
	"context"
	"errors"
	"time"

	"github.com/temporalio/features/features/update/updateutil"
	"github.com/temporalio/features/harness/go/harness"
	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/workflow"
)

const (
	update         = "doSomeStuff"
	shutdownSignal = "shutdown_signal"
)

var Feature = harness.Feature{
	Workflows:  Workflow,
	Activities: TheActivity,
	Execute: func(ctx context.Context, runner *harness.Runner) (client.WorkflowRun, error) {
		runner.Log.Info("Starting validation_replay update test execution")

		if reason := updateutil.CheckServerSupportsUpdate(ctx, runner.Client); reason != "" {
			return nil, runner.Skip(reason)
		}

		runner.Log.Info("Starting workflow execution (will test validation replay behavior)")
		run, err := runner.ExecuteDefault(ctx)
		if err != nil {
			return nil, err
		}
		runner.Log.Info("Workflow started", "workflowID", run.GetID(), "runID", run.GetRunID())

		runner.Log.Info("Sending update (validation should only run once, not on replay)", "updateName", update, "waitForStage", "Completed")
		handle, err := runner.Client.UpdateWorkflow(
			ctx,
			client.UpdateWorkflowOptions{
				WorkflowID:   run.GetID(),
				RunID:        run.GetRunID(),
				UpdateName:   update,
				WaitForStage: client.WorkflowUpdateStageCompleted,
			},
		)
		runner.Require.NoError(err)
		runner.Log.Info("Update request returned", "updateID", handle.UpdateID())

		runner.Log.Info("Getting update result")
		runner.Require.NoError(handle.Get(ctx, nil))
		runner.Log.Info("Update completed successfully")

		runner.Log.Info("Sending shutdown signal to workflow")
		runner.Require.NoError(runner.Client.SignalWorkflow(ctx, run.GetID(), run.GetRunID(), shutdownSignal, nil))
		runner.Log.Info("Validation_replay update test completed successfully")
		return run, nil
	},
}

var validationCounter = 0

// Workflow hosts an update handler that is intentionally broken such that
// validation passes on the first invocation but not subsequent invokcations.
// The SDK under test must skip update validation during replay. If it does not,
// the second call to the Validator here (which will happen during replay) will
// fail and therefore the update will not run, causing the commands generated by
// the replay to diverge from the original events and thus replay to fail.
func Workflow(ctx workflow.Context) error {
	logger := workflow.GetLogger(ctx)
	logger.Info("Validation replay workflow started, setting up update handler with stateful validator")

	if err := workflow.SetUpdateHandlerWithOptions(ctx, update,
		func(ctx workflow.Context) error {
			logger.Info("Update handler invoked, executing activity")
			var result int
			aopts := workflow.ActivityOptions{StartToCloseTimeout: 5 * time.Second}
			err := workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, aopts), TheActivity).Get(ctx, &result)
			logger.Info("Activity completed", "result", result, "error", err)
			return nil
		},
		workflow.UpdateHandlerOptions{Validator: func() error {
			// Don't do this! We only touch this global from within a validation
			// handler for test purposes so that this validation function fails
			// if it is called a second time (as it would be if it were to be
			// called during replay)
			validationCounter++
			logger.Info("Validator invoked", "validationCounter", validationCounter)
			if validationCounter > 1 {
				logger.Error("Validation failed (should not happen during replay)", "validationCounter", validationCounter)
				return errors.New("failing validation")
			}
			logger.Info("Validation passed")
			return nil
		}},
	); err != nil {
		return err
	}
	logger.Info("Update handler registered, waiting for shutdown signal")

	_ = workflow.GetSignalChannel(ctx, shutdownSignal).Receive(ctx, nil)
	logger.Info("Shutdown signal received, workflow completing")
	return nil
}

func TheActivity(ctx context.Context) (int, error) {
	return 1, nil
}
